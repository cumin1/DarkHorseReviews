# Redis笔记

### Redis

redis是一个基于内存存储的nosql数据库，安装redis需要将安装包解压到linux某个目录中，然后手动启动redis-server命令。

解压完之后安装需要的依赖并且编译redis（因为redis底层是C实现的）

```bash
yum install -y gcc tcl
tar -xzf redis-6.2.6.tar.gz
cd redis-6.2.6
make && make install
```

编译完成可以试着启动一次：

```bash
cd /usr/local/bin
redis-server
```

安装完之后需要根据需求改几行配置文件：

```bash
# 这一行本来是127.0.0.1 意思是只能本地访问 改成0.0.0.0就可以远程访问这台主机的redis
bind 0.0.0.0  
# 守护进程 修改为yes之后就可以在后台运行
daemonize yes
# 密码 设置后访问redis需要输入密码
requirepass 123456
```

修改完配置文件需要在启动的时候指定配置文件才可以生效：

```bash
redis-server redis.conf

ps -ef | grep redis  # 启动之后可以通过这个命令看一下有没有成功运行
kill -9 进程id   # 通过这个命令可以停止这个进程
```

### 设置redis开机自启

首先需要创建一个系统文件

```bash
vi /etc/systemd/system/redis.service
```

内容:

```
[Unit]
Description=redis-server
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```

重载系统服务:

```bash
systemctl daemon-reload
systemctl start redis  # 启动redis
systemctl status redis # 看状态
systemctl stop redis 
systemctl restart redis
systemctl enable redis  # 设置开启自启redis
```

### redis-cli连接redis

-h 指定地址 默认 127.0.0.1

-p 指定端口 默认 6379

-a 指定密码

```bash
redis-cli -a 123456
```

### Springboot项目中使用SpringDataRedis

1.在pom.xml文件中引入依赖

```xml
<!--redis依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!--common-pool-->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

2.在yaml配置中配置必要的配置 （spring默认使用lettuce连接 如果要使用jedis的连接池需要额外引入pom）

```
spring:
  redis:
    host: 192.168.114.128
    port: 6379
    password: 123456
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: 100ms
```

3.配置SpringDataRedis的序列化方法(不然写入redis的东西都会经过jdk自带的序列化方法导致key、value名称混乱)

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){
        // 创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}
```

4.使用

```java
@Autowired
private RedisTemplate<String,Object> redisTemplate;
redisTemplate.opsForValue().set("name", "xiaohu");
Object name = redisTemplate.opsForValue().get("name");
```



# 黑马点评项目笔记

### Redis在项目中的应用

1.实现商户查询缓存

2.在短信登录中共享session应用

3.在达人探店中实现基于List的点赞列表

4.实现基于SortedSet的点赞排行榜

5.优惠券秒杀功能中用Redis做计数器、Lua脚本Redis、分布式锁、Redis的消息队列

6.好友关注功能用到了Redis的Set集合 实现关注、取关、共同关注、消息推送

7.附近的商户功能：GeoHash数据结构

8.UV统计：HyperLogLog数据结构

9.用户签到：BitMap数据结构



### 基于Session实现登录

1.发送短信验证码

提交手机号 > 校验手机号 > 生成验证码 > 保存验证码到session > 发送验证码

```java
// 校验手机号
if (RegexUtils.isPhoneInvalid(phone)) {
    // 如果手机号不符合要求返回错误信息
    return Result.fail("手机号格式错误!");
}
// 生成一个验证码
String code = RandomUtil.randomNumbers(6);
// 保存验证码到session
session.setAttribute("code", code);
// 发送验证码
log.debug("发送短信验证码成功: {}",code);
return Result.ok();
```

2.短信验证码登录、注册

提交手机号 > 校验验证码 > 将验证码和session中的验证码进行比较 > 根据手机号查询用户(有就登录没有就注册) > 保存用户到session 

```java
public Result login(LoginFormDTO loginForm, HttpSession session) {
    // 提交手机号
    String userCode = loginForm.getCode();
    String phone = loginForm.getPhone();
    // 校验手机号
    if (RegexUtils.isPhoneInvalid(phone)) {
        // 如果手机号不符合要求返回错误信息
        return Result.fail("手机号格式错误!");
    }
    // 校验验证码
    if (RegexUtils.isCodeInvalid(userCode)) {
        return Result.fail("无效验证码!");
    }
    // 将验证码和session中的验证码进行比较
    Object sessionCode = session.getAttribute("code");
    if (!sessionCode.toString().equals(userCode)){
        return Result.fail("验证码错误!");
    }
    // 根据手机号查询用户(有就登录没有就注册)
    User user = query().eq("phone", phone).one();
    if(user == null){
        user = CreateUserByPhone(phone);
    }
    // 保存用户到session
    session.setAttribute("user", user);
    return Result.ok();
}

/**
 * 根据电话号码插入新用户
 * @param phone
 * @return
 */
private User CreateUserByPhone(String phone) {
    User user = new User();
    user.setPhone(phone);
    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));
    save(user); // 保存user到user表 mp提供的功能
    return user;
}
```



3.校验登录状态

请求携带cookie > 从cookie中拿到sessionid > 从session中获取用户(没有用户则拦截请求) > 保存用户信息到ThreadLocal

登录校验一般在拦截器中实现，因为有很多请求都需要登录校验，所以就进行统一拦截，首先需要一个类继承HandlerInterceptor类，接着创建配置类来注册该拦截器。

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从用户请求携带的cookies中得到session
        HttpSession session = request.getSession();
        User user = (User)session.getAttribute("user");
        // 判断用户是否存在
        if (user == null) {
            response.setStatus(401);
            return false;
        }

        // 如果存在 将用户信息保存到ThreadLocal
        UserDTO userDTO = new UserDTO();
        BeanUtils.copyProperties(user, userDTO);
        UserHolder.saveUser(userDTO);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户 避免内存泄露
        UserHolder.removeUser();
    }
}

@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns("/user/code","/user/login",
                        "/blog/hot","/shop/**","/shop-type/**","/upload/**",
                        "/voucher/**");
    }
}
```



### 发现第一个问题

集群的session的共享问题，多台tomcat服务器之间不能共享session数据，导致当请求切换到另一台tomcat时会导致数据丢失。

解决方法：基于Redis来实现共享session

1.发送验证码

提交手机号 > 校验手机号 > 生成验证码 > 保存验证码到redis> 发送验证码

redis的key:  phone:手机号



2.短信验证码登录、注册

提交手机号 > 校验验证码 > 将验证码和redis中的验证码进行比较 > 根据手机号查询用户(有就登录没有就注册) > 保存用户到redis > 把随机token返回到客户端

redis的key:  随机token为key   value的数据类型：hash类型

```java
// 将验证码和redis中的验证码进行比较
Object sessionCode = redisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);
if (!sessionCode.toString().equals(userCode)){
    return Result.fail("验证码错误!");
}
// 根据手机号查询用户(有就登录没有就注册)
User user = query().eq("phone", phone).one();
if(user == null){
    user = CreateUserByPhone(phone);
}
UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
Map<String, Object> userMap = BeanUtil.beanToMap(userDTO);
// 保存用户到redis
String token = UUID.randomUUID().toString(true);
redisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token,userMap);
redisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL, TimeUnit.SECONDS); // 设置有效期
// 返回token给客户端
return Result.ok(token);
```



3.校验登录状态

请求携带token> 使用token获取用户信息(没有用户则拦截请求)> 更新用户token的有效期 > 保存用户信息到ThreadLocal

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 使用token获取用户信息(没有用户则拦截请求)
    String token = request.getHeader("authorization");
    if (StrUtil.isBlank(token)) {
        response.setStatus(401);
        return false;
    }
    Map<Object, Object> userMap = redisTemplate.opsForHash().entries(LOGIN_USER_KEY+token);
    // 判断用户是否存在
    if (userMap.isEmpty()) {
        response.setStatus(401);
        return false;
    }
    // 将查询到的Hash转为UserDto
    UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
    // 如果存在 将用户信息保存到ThreadLocal
    UserHolder.saveUser(userDTO);
    // 更新用户token的有效期
    redisTemplate.expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL, TimeUnit.SECONDS);
    return true;
}
```



### 登录拦截器优化

现在已经可以做到当用户访问某个接口的时候刷新token，但是有一个问题，就是如果用户访问没有被拦截的接口（如首页、商户页面）并没有通过拦截器，这样导致token并不会被刷新。

解决这个问题的办法就是再加一个拦截一切路径的拦截器：

这个拦截器做的任务就是获取token并且刷新token有效期，顺带把用户信息放到ThreadLocal中，如果没有token就放行，原先的拦截器则是读取ThreadLocal中的用户信息，如果读取不到则拦截，如果存在则放行。



```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new LoginInterceptor())
            .excludePathPatterns("/user/code","/user/login",
                    "/blog/hot","/shop/**","/shop-type/**","/upload/**",
                    "/voucher/**")
            .order(1);

    // 拦截所有请求
    registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate))
            .addPathPatterns("/**")
            .order(0);
}
```

拦截器中可以使用.order方法设置拦截器的执行顺序 值越小越先执行



### 为商户详情接口添加缓存

提交商铺id > 从redis查询商户缓存 (如果命中直接返回结果) >如果没命中 >查询数据库>如果查到了返回并写入信息到缓存中

key采用 cache:shop:id value使用String类型 通过BeanUtil和JsonUtil进行转换存储进redis

```java
@Service
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @Override
    public Result queryById(Long id) {
        String key = CACHE_SHOP_KEY + id;
        // 1.从redis查询商户缓存 如果命中直接返回结果)
        String shopJson = stringRedisTemplate.opsForValue().get(key);
        if (StrUtil.isNotBlank(shopJson)) {
            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
            return Result.ok(shop);
        }
        // 2.如果没命中则去数据库进行查询
        Shop shop = getById(id);
        // 3.数据库如果没查询到则返回异常信息
        if (shop == null) {
            return Result.fail("店铺不存在");
        }
        // 4.如果有商户信息 则写入缓存 并返回结果
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));
        return Result.ok(shop);
    }
}
```

### 缓存更新策略

当数据库发生改变的时候如果redis中的数据不更新的话，用户获取到的就是历史的旧数据，在很多业务中这一点是不允许的，所以需要制定缓存的更新策略

* 内存淘汰：利用Redis的配置，当内存不足时自动删除部分数据，下次查询时更新缓存，一致性差、没有维护成本
* 超时剔除：给缓存数据添加TTL时间，到期自动删除，下次查询时更新缓存，一致性一般、维护成本低
* 主动更新：编写业务逻辑，在修改数据库的同时，更新缓存，一致性好、维护成本高

> 低一致性的需求可以使用内存淘汰机制，高一致性需求使用主动更新策略。

> 线程安全问题：无论是先删除缓存再操作数据库还是先操作数据库再删除缓存都有可能遇到线程安全问题，后果就是缓存和数据库信息不一致。
>
> 但相对来说先操作数据库的线程安全问题发生的可能性较低

最终总结出了缓存更新的最佳方案：

低一致性需求：使用Redis自带的内存淘汰机制

高一致性需求：主动更新，并以超时剔除作为兜底方案

读操作：

* 缓存命中则直接返回
* 缓存未命中则查询数据库，并写入缓存，设定超时时间

写操作：

* 先写数据库，然后再删除缓存
* 要确保数据库与缓存操作的原子性



### 给查询商铺的缓存添加超时剔除和主动更新的策略

* 查询店铺：缓存未命中则查询，将结果写入缓存*并设置超时时间*
* 修改店铺：先修改数据库，再删除缓存

```java
/**
 * 更新商铺信息
 * @param shop 商铺数据
 * @return 无
 */
@PutMapping
public Result updateShop(@RequestBody Shop shop) {
    return shopService.update(shop);
}

@Override
@Transactional
public Result update(Shop shop) {
    Long id = shop.getId();
    if (id == null) {
        return Result.fail("店铺id不能为空");
    }
    // 1.更新数据库
    updateById(shop);
    // 2.删除缓存
    stringRedisTemplate.delete(CACHE_SHOP_KEY+id);
    return Result.ok();
}
```

